#!/usr/bin/env bash
set -euo pipefail

list_commands() {
  echo "Available commands: add, update, list, install, remove"
}

if [[ $# -eq 0 ]]; then
  echo "Error: Requires a command"
  list_commands
  exit 1
fi

BIN_DIR=$HOME/.local/bin

# XDG directories
XDG_CACHE_HOME=$HOME/.cache
XDG_CONFIG_HOME=$HOME/.config
XDG_DATA_HOME=$HOME/.local/share

# PPM directories
PPM_CONFIG_HOME=$XDG_CONFIG_HOME/ppm
PPM_DATA_HOME=$XDG_DATA_HOME/ppm

# PPM files
PPM_BIN_FILE=$BIN_DIR/ppm
PPM_BIN_URL=https://raw.githubusercontent.com/maxcole/ppm/refs/heads/main/ppm
PPM_SOURCES_FILE=$PPM_CONFIG_HOME/sources.list


# Install dependencies using the OS specific package manager (apt or homebrew)
install_dep() {
  for dep in "$@"; do
    if [[ "$(os)" == "linux" ]]; then
      sudo apt install $dep -y
    elif [[ "$(os)" == "macos" ]]; then
      if ! brew list "$dep" &>/dev/null; then
        brew install $dep
      elif brew outdated | grep -q "^$dep"; then
        brew upgrade "$dep"
      else
        echo "$dep is installed and up-to-date"
      fi
    fi
  done
}


# Detect the CPU architecture
arch() {
  local arch=$(uname -m)

  if [[ "$arch" == "aarch64" || "$arch" == "arm64" ]]; then
    echo "arm64"
  else
    echo "amd64"
  fi
}


# Detect the OS
os() {
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    echo "linux"
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    echo "macos"
  else
    echo "unsupported"
  fi
}


# Add a git repository URL to sources.list
add() {
  if [[ $# -eq 0 ]]; then
    echo "Error: add requires a git URL"
    echo "Usage: ppm add <git-url>"
    exit 1
  fi

  local url="$1"

  # Create config directory if it doesn't exist
  mkdir -p "$PPM_CONFIG_HOME"

  # Create sources.list if it doesn't exist
  touch "$PPM_SOURCES_FILE"

  # Check if URL already exists in sources.list
  if grep -qxF "$url" "$PPM_SOURCES_FILE" 2>/dev/null; then
    echo "Source already exists: $url"
    return 0
  fi

  # Append URL to sources.list
  echo "$url" >> "$PPM_SOURCES_FILE"
  echo "Added source: $url"
}


collect_repos() {
  REPOS=()

  # Read file into array, skipping empty lines and comments
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    REPOS+=("$line")
  done < "$PPM_SOURCES_FILE"
}


collect_packages() {
  collect_repos
  PACKAGES=()

  for repo in "${REPOS[@]}"; do
    local repo_name="${repo##*/}"      # Remove everything before last /
    repo_name="${repo_name%.git}"      # Remove .git extension

    while IFS= read -r dir; do
      PACKAGES+=("$repo_name/$(basename "$dir")")
    done < <(ls -d $PPM_DATA_HOME/$repo_name/packages/*/)
  done
}


# Update ppm itself by downloading from the source URL
update_self() {
  echo "Updating ppm..."
  curl -fsSL -o "$PPM_BIN_FILE" "$PPM_BIN_URL"
  chmod +x "$PPM_BIN_FILE"
  echo "ppm updated successfully"
}

# Iterate over repos listed in $PPM_SOURCES_FILE and clone them to $PPM_DATA_HOME
update() {
  # Handle self-update
  if [[ $# -gt 0 && "$1" == "ppm" ]]; then
    update_self
    return
  fi

  collect_repos

  # Iterate over repos and clone to $PPM_DATA_HOME
  for repo in "${REPOS[@]}"; do
    # Extract repo name (everything after last / and before .git)
    local repo_name="${repo##*/}"      # Remove everything before last /
    repo_name="${repo_name%.git}"      # Remove .git extension

    if [ ! -d $PPM_DATA_HOME/$repo_name ]; then
      echo "Cloning: $repo"
      git clone $repo $PPM_DATA_HOME/$repo_name
    else
      # Check for uncommitted changes or untracked files
      if ! git -C "$PPM_DATA_HOME/$repo_name" diff --quiet || \
         ! git -C "$PPM_DATA_HOME/$repo_name" diff --cached --quiet || \
         [[ -n $(git -C "$PPM_DATA_HOME/$repo_name" status --porcelain) ]]; then
        echo "Skipping $repo_name: has uncommitted changes. Please commit or stash them first."
        continue
      fi

      echo "Updating: $repo_name"
      git -C "$PPM_DATA_HOME/$repo_name" pull
    fi
  done
}


# List the packages found in the cached repositories
# Optionally filter by a substring pattern
list() {
  local filter="${1:-}"
  collect_packages
  for pkg in "${PACKAGES[@]}"; do
    if [[ -z "$filter" ]] || [[ "$pkg" == *"$filter"* ]]; then
      echo "$pkg"
    fi
  done
}

package_links() {
  find "$package_dir/home" -type f | while read -r file; do
    echo "${file#$package_dir/home/}"
  done
}

# Install one or more packages as requested by the user
install() {
  if $force; then
    remove "$@"
  fi
  installer "$@"
}

installer() {
  collect_repos
  requested_packages=("$@")

  for pkg in "${requested_packages[@]}"; do
    local ignore_args=()

    for repo in "${REPOS[@]}"; do
      # Extract repo name (everything after last / and before .git)
      local repo_name="${repo##*/}"      # Remove everything before last /
      repo_name="${repo_name%.git}"      # Remove .git extension

      # If the requested package is from a specific repo, i.e. `ppm install repo/pkg`
      if [[ "$pkg" == */* && "$repo_name" != "${pkg%/*}" ]]; then
        continue
      fi

      package_name="${pkg#*/}"
      package_dir=$PPM_DATA_HOME/$repo_name/packages/$package_name

      # If the package name is not found in this repo then skip to the next, otherwise
      # set has_installer to true or false based on if the package has an install.sh script or not
      if [[ ! -d $package_dir ]]; then
        continue
      else
        echo "Install $repo_name/$package_name"
        [[ -f "$package_dir/install.sh" ]] && has_installer=true || has_installer=false
      fi

      # If the package declares dependencies then spawn a subshell to install them first
      if $has_installer; then
        (
          source "$package_dir/install.sh"
          if type dependencies &>/dev/null; then
            deps=$(dependencies)
            for dep in $deps; do
              # only pass config_flag and force_flag if they are non empty values
              "$0" "installer" ${config_flag:+"$config_flag"} ${force_flag:+"$force_flag"} "$dep"
            done
          fi
        )
      fi

      # If -f (force) was used then remove any possible existing symlinks first
      # if $force; then
      #   links=$(package_links)
      #   for link in $links; do
      #     if [[ -L "$HOME/$link" ]]; then
      #       rm "$HOME/$link"
      #     fi
      #   done
      # fi

      # If installer has a paths function then create those directories
      # followed by running the pre_install function if it is defined
      if $has_installer; then
        (
          source "$package_dir/install.sh"
          # if type paths &>/dev/null; then
          #   pkg_dirs=$(paths)
          #   for dir in $pkg_dirs; do
          #     mkdir -p $dir
          #   done
          # fi
          if type pre_install &>/dev/null && [[ -z "$config_flag" ]]; then
            pre_install
          fi
        )
      fi

      # Use stow to make softlinks into the user's home directory
      if [[ -d $package_dir/home ]]; then
        stow --no-folding ${ignore_args[@]+"${ignore_args[@]}"} -d $package_dir -t $HOME home
        # Collect files to ignore for lower-priority repos
        while IFS= read -r file; do
          if [[ -n "$file" ]]; then
            # stow --ignore matches against the full relative path
            # Escape dots for regex
            local escaped="${file//./\\.}"
            ignore_args+=("--ignore=^${escaped}\$")
          fi
        done < <(package_links)
      fi

      # If the installer has an install_linux or install_mac function then run it
      # followed by post_install if it exists
      if $has_installer; then
        (
          source "$package_dir/install.sh"

          func_name="install_$(os)" # install_linux or install_macos
          if type $func_name &>/dev/null && [[ -z "$config_flag" ]]; then
            $func_name
          fi

          if type post_install &>/dev/null && [[ -z "$config_flag" ]]; then
            post_install
          fi

          if type "space_path" &>/dev/null; then
            mkdir -p $(space_path)
            if [[ -d $package_dir/space  ]]; then
              # stow --no-folding -d $package_dir -t $(space_path) space
              stow -d $package_dir -t $(space_path) space
            fi
            if type "space_install" &>/dev/null; then
              pushd $(space_path) > /dev/null
              space_install
              popd > /dev/null
            fi
          fi
        )
      fi
    done
  done
}


# Remove one or more packages as requested by the user
remove() {
  collect_repos

  requested_packages=("$@")
  for pkg in "${requested_packages[@]}"; do

    for repo in "${REPOS[@]}"; do
      # Extract repo name (everything after last / and before .git)
      local repo_name="${repo##*/}"      # Remove everything before last /
      repo_name="${repo_name%.git}"      # Remove .git extension

      pkg_dir=$PPM_DATA_HOME/$repo_name/packages/$pkg

      # If the package name is not found then skip to the next
      if [[ ! -d $pkg_dir ]]; then
        continue
      else
        echo "Remove $repo_name/$pkg"
        [[ -f "$pkg_dir/install.sh" ]] && has_installer=true || has_installer=false
      fi

      if $has_installer; then
        (
          source "$pkg_dir/install.sh"
          if type pre_remove &>/dev/null; then
            pre_remove
          fi
        )
      fi

      # Use stow to remove softlinks from the user's home directory
      [[ -d $pkg_dir/home ]] && stow -D -d $pkg_dir -t $HOME home

      if $has_installer; then
        (
          source "$pkg_dir/install.sh"
          # if type paths &>/dev/null; then
          #   pkg_dirs=$(paths)
          #   for dir in $pkg_dirs; do
          #     rm -rf $dir
          #   done
          # fi
          func_name="remove_$(os)" # remove_linux or remove_macos
          if type $func_name &>/dev/null; then
            $func_name
          fi
          if type post_remove &>/dev/null; then
            post_remove
          fi
        )
      fi
    done
  done
}

main() {
  local command="$1" config=false config_flag="" force=false force_flag=""
  shift

  # NOTE: Have to pass -c before -f b/c we are keeping it simple for now, i.e. not using getopt
  [[ "$#" > 0 && "$1" == "-c" ]] && { config=true; config_flag="-c"; shift; }
  [[ "$#" > 0 && "$1" == "-f" ]] && { force=true; force_flag="-f"; shift; }

  if declare -f "$command" > /dev/null; then
    "$command" "$@"
  else
    echo "Error: Unknown command '$command'"
    list_commands
    exit 1
  fi
}

main "$@"

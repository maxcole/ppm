#!/usr/bin/env bash
set -euo pipefail

list_commands() {
  echo "Available commands: add, update, list, install, remove"
}

if [[ $# -eq 0 ]]; then
  echo "Error: Requires a command"
  list_commands
  exit 1
fi


# XDG directories
XDG_BIN_DIR=$HOME/.local/bin
XDG_CONFIG_DIR=$HOME/.config
XDG_LOCAL_SHARE_DIR=$HOME/.local/share

# PPM directories and files
PPM_BIN_FILE=$XDG_BIN_DIR/ppm
PPM_BIN_URL=https://raw.githubusercontent.com/maxcole/ppm/refs/heads/main/ppm
PPM_CONFIG_DIR=$XDG_CONFIG_DIR/ppm
PPM_LOCAL_SHARE_DIR=$XDG_LOCAL_SHARE_DIR/ppm
PPM_SOURCES_FILE=$PPM_CONFIG_DIR/sources.list


# Install dependencies using the OS specific pacakge manager (apt or homebrew)
install_dep() {
  for dep in "$@"; do
    if [[ "$(os)" == "linux" ]]; then
      sudo apt install $dep -y
    elif [[ "$(os)" == "macos" ]]; then
      if ! brew list "$dep" &>/dev/null; then
        brew install $dep
      elif brew outdated | grep -q "^$dep"; then
        brew upgrade "$dep"
      else
        echo "$dep is installed and up-to-date"
      fi
    fi
  done
}


# Detect the CPU architecture
arch() {
  local arch=$(uname -m)

  if [[ "$arch" == "aarch64" || "$arch" == "arm64" ]]; then
    echo "arm64"
  else
    echo "amd64"
  fi
}


# Detect the OS
os() {
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    echo "linux"
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    echo "macos"
  else
    echo "unsupported"
  fi
}


# Add a git repository URL to sources.list
add() {
  if [[ $# -eq 0 ]]; then
    echo "Error: add requires a git URL"
    echo "Usage: ppm add <git-url>"
    exit 1
  fi

  local url="$1"

  # Create config directory if it doesn't exist
  mkdir -p "$PPM_CONFIG_DIR"

  # Create sources.list if it doesn't exist
  touch "$PPM_SOURCES_FILE"

  # Check if URL already exists in sources.list
  if grep -qxF "$url" "$PPM_SOURCES_FILE" 2>/dev/null; then
    echo "Source already exists: $url"
    return 0
  fi

  # Append URL to sources.list
  echo "$url" >> "$PPM_SOURCES_FILE"
  echo "Added source: $url"
}


collect_repos() {
  REPOS=()

  # Read file into array, skipping empty lines and comments
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    REPOS+=("$line")
  done < "$PPM_SOURCES_FILE"
}


collect_packages() {
  collect_repos
  PACKAGES=()

  for repo in "${REPOS[@]}"; do
    local repo_name="${repo##*/}"      # Remove everything before last /
    repo_name="${repo_name%.git}"      # Remove .git extension

    while IFS= read -r dir; do
      PACKAGES+=("$repo_name/$(basename "$dir")")
    done < <(ls -d $PPM_LOCAL_SHARE_DIR/$repo_name/packages/*/)
  done
}


# Update ppm itself by downloading from the source URL
update_self() {
  echo "Updating ppm..."
  curl -fsSL -o "$PPM_BIN_FILE" "$PPM_BIN_URL"
  chmod +x "$PPM_BIN_FILE"
  echo "ppm updated successfully"
}

# Iterate over repos listed in $PPM_SOURCES_FILE and clone them to $PPM_LOCAL_SHARE_DIR
update() {
  # Handle self-update
  if [[ $# -gt 0 && "$1" == "ppm" ]]; then
    update_self
    return
  fi

  collect_repos

  # Iterate over repos and clone to $PPM_LOCAL_SHARE_DIR
  for repo in "${REPOS[@]}"; do
    # Extract repo name (everything after last / and before .git)
    local repo_name="${repo##*/}"      # Remove everything before last /
    repo_name="${repo_name%.git}"      # Remove .git extension

    if [ ! -d $PPM_LOCAL_SHARE_DIR/$repo_name ]; then
      echo "Cloning: $repo"
      git clone $repo $PPM_LOCAL_SHARE_DIR/$repo_name
    else
      # Check for uncommitted changes or untracked files
      if ! git -C "$PPM_LOCAL_SHARE_DIR/$repo_name" diff --quiet || \
         ! git -C "$PPM_LOCAL_SHARE_DIR/$repo_name" diff --cached --quiet || \
         [[ -n $(git -C "$PPM_LOCAL_SHARE_DIR/$repo_name" status --porcelain) ]]; then
        echo "Skipping $repo_name: has uncommitted changes. Please commit or stash them first."
        continue
      fi

      echo "Updating: $repo_name"
      git -C "$PPM_LOCAL_SHARE_DIR/$repo_name" pull
    fi
  done
}


# List the packages found in the cached repositories
list() {
  collect_packages
  for pkg in "${PACKAGES[@]}"; do
    echo "$pkg"
  done
}


# Install one or more packages as requested by the user
install() {
  collect_repos

  requested_packages=("$@")
  for pkg in "${requested_packages[@]}"; do

    for repo in "${REPOS[@]}"; do
      # Extract repo name (everything after last / and before .git)
      local repo_name="${repo##*/}"      # Remove everything before last /
      repo_name="${repo_name%.git}"      # Remove .git extension

      pkg_dir=$PPM_LOCAL_SHARE_DIR/$repo_name/packages/$pkg

      # If the package name is not found then skip to the next
      # , otherwise source install.sh if the package has it
      if [[ ! -d $pkg_dir ]]; then
        echo "Install $repo_name/$pkg -- Not Found"
        continue
      else
        echo "Install $repo_name/$pkg"
        [[ -f "$pkg_dir/install.sh" ]] && has_installer=true || has_installer=false
      fi

      # Check if the package has install.sh and source it
      if $has_installer; then
        (
          source "$pkg_dir/install.sh"
          if type dependencies &>/dev/null; then
            deps=$(dependencies)
            for dep in $deps; do
              "$0" "install" "$dep"
            done
          fi
          if type pre_install &>/dev/null; then
            pre_install
          fi
        )
      fi

      # Use stow to make softlinks into the user's home directory
      [[ -d $pkg_dir/home ]] && stow -d $pkg_dir -t $HOME home

      if $has_installer; then
        (
          source "$pkg_dir/install.sh"
          func_name="install_$(os)" # install_linux or install_macos
          if type $func_name &>/dev/null; then
            $func_name
          fi
          if type post_install &>/dev/null; then
            post_install
          fi
        )
      fi
    done
  done
}


# Remove one or more packages as requested by the user
# TODO: Implement and test in ppm and packages; right now the only diff
# between install and remove is the stow -D flag which removes existing symlinks
remove() {
  collect_repos

  requested_packages=("$@")
  for pkg in "${requested_packages[@]}"; do

    for repo in "${REPOS[@]}"; do
      # Extract repo name (everything after last / and before .git)
      local repo_name="${repo##*/}"      # Remove everything before last /
      repo_name="${repo_name%.git}"      # Remove .git extension

      pkg_dir=$PPM_LOCAL_SHARE_DIR/$repo_name/packages/$pkg

      # If the package name is not found then skip to the next
      if [[ ! -d $pkg_dir ]]; then
        echo "Remove $repo_name/$pkg -- Not Found"
        continue
      else
        echo "Remove $repo_name/$pkg"
        [[ -f "$pkg_dir/install.sh" ]] && has_installer=true || has_installer=false
      fi

      if $has_installer; then
        (
          source "$pkg_dir/install.sh"
          if type pre_remove &>/dev/null; then
            pre_remove
          fi
        )
      fi

      # Use stow to remove softlinks from the user's home directory
      [[ -d $pkg_dir/home ]] && stow -D -d $pkg_dir -t $HOME home

      if $has_installer; then
        (
          source "$pkg_dir/install.sh"
          func_name="remove_$(os)" # remove_linux or remove_macos
          if type $func_name &>/dev/null; then
            $func_name
          fi
          if type post_remove &>/dev/null; then
            post_remove
          fi
        )
      fi
    done
  done
}

main() {
  local command="$1"
  shift

  if declare -f "$command" > /dev/null; then
    "$command" "$@"
  else
    echo "Error: Unknown command '$command'"
    list_commands
    exit 1
  fi
}

main "$@"

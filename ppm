#!/usr/bin/env bash
set -euo pipefail

[[ $# -eq 0 ]] && exit 0

PPM_CACHE_DIR=$HOME/.cache/ppm

PPM_CONFIG_DIR=$HOME/.config/ppm
PPM_SOURCES_FILE=$PPM_CONFIG_DIR/sources.list


collect_repos() {
  REPOS=()
    
  # Read file into array, skipping empty lines and comments
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    REPOS+=("$line")
  done < "$PPM_SOURCES_FILE"
}


collect_packages() {
  collect_repos
  PACKAGES=()

  for repo in "${REPOS[@]}"; do
    local repo_name="${repo##*/}"      # Remove everything before last /
    repo_name="${repo_name%.git}"      # Remove .git extension

    while IFS= read -r dir; do
      PACKAGES+=("$repo_name/$(basename "$dir")")
    done < <(ls -d $PPM_CACHE_DIR/$repo_name/packages/*/)
  done
}


# Iterate over repos listed in $PPM_SOURCES_FILE and clone them to $PPM_CACHE_DIR
update() {
  collect_repos

  # Iterate over repos and clone to $PPM_CACHE_DIR
  for repo in "${REPOS[@]}"; do
    # Extract repo name (everything after last / and before .git)
    local repo_name="${repo##*/}"      # Remove everything before last /
    repo_name="${repo_name%.git}"      # Remove .git extension
        
    if [ ! -d $PPM_CACHE_DIR/$repo_name ]; then
      echo "Cloning: $repo"
      git clone $repo $PPM_CACHE_DIR/$repo_name
    else
      echo "Skipping existing repo: $repo"
    fi
  done
}


# List the packages found in the cached repositories
list() {
  collect_packages
  for pkg in "${PACKAGES[@]}"; do
    echo "$pkg"
  done
}


# Install one or more packages as requested by the user
install() {
  collect_repos

  requested_packages=("$@")
  for pkg in "${requested_packages[@]}"; do

    for repo in "${REPOS[@]}"; do
      # Extract repo name (everything after last / and before .git)
      local repo_name="${repo##*/}"      # Remove everything before last /
      repo_name="${repo_name%.git}"      # Remove .git extension

      pkg_dir=$PPM_CACHE_DIR/$repo_name/packages/$pkg

      # If the package name is not found then skip to the next, otherwise source install.sh if the package has it
      if [[ ! -d $pkg_dir ]]; then
        echo "Package not found in $repo_name: $pkg"
        continue
      fi

      # Check if the package has install.sh and source it
      [[ -f "$pkg_dir/install.sh" ]] && has_installer=true || has_installer=false
      $has_installer && source "$pkg_dir/install.sh"

      $has_installer && pre_install

      # Use stow to make softlinks into the user's home directory
      [[ -d $pkg_dir/home ]] && stow -d $pkg_dir -t $HOME home

      # invoke install_linux or install_macos
      func_name="install_$(os)"
      $has_installer && $func_name

      $has_installer && post_install
    done
  done
}


main() {
  source $PPM_CACHE_DIR/library.sh
  local command="$1"
  shift

  if declare -f "$command" > /dev/null; then
    "$command" "$@"
  else
    echo "Error: Unknown command '$command'"
    echo "Available commands: update, list, install"
  fi
}

main "$@"

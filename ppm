#!/usr/bin/env bash
set -euo pipefail

list_commands() {
  echo "Available commands: src, update, list, install, remove, show, completions"
}

if [[ $# -eq 0 ]]; then
  echo "Error: Requires a command"
  list_commands
  exit 1
fi

BIN_DIR=$HOME/.local/bin
LIB_DIR=$HOME/.local/lib

# XDG directories
XDG_CACHE_HOME=$HOME/.cache
XDG_CONFIG_HOME=$HOME/.config
XDG_DATA_HOME=$HOME/.local/share

# PPM directories
PPM_CACHE_HOME=$XDG_CACHE_HOME/ppm
PPM_CONFIG_HOME=$XDG_CONFIG_HOME/ppm
PPM_DATA_HOME=$XDG_DATA_HOME/ppm
PPM_LIB_DIR=$LIB_DIR/ppm

# PPM files
PPM_BIN_FILE=$BIN_DIR/ppm
PPM_BIN_URL=https://raw.githubusercontent.com/maxcole/ppm/refs/heads/main/ppm
PPM_SOURCES_FILE=$PPM_CONFIG_HOME/sources.list

# source lib files
if [[ -d "$PPM_LIB_DIR" ]]; then
  for lib_file in "$PPM_LIB_DIR"/*.sh; do
    [[ -f "$lib_file" ]] && source "$lib_file"
  done
fi


# Detect the CPU architecture
arch() {
  local arch=$(uname -m)

  if [[ "$arch" == "aarch64" || "$arch" == "arm64" ]]; then
    echo "arm64"
  else
    echo "amd64"
  fi
}

# Detect the OS
os() {
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    echo "linux"
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    echo "macos"
  else
    echo "unsupported"
  fi
}

# search in file and add/remove as requested
add_to_file() {
  local file="$1"
  shift
  [[ -f "$file" ]] || touch "$file"

  for string in "$@"; do
    _string_in_file "$string" "$file" || echo "$string" >> "$file"
  done
}

remove_from_file() {
  local file="$1"
  shift
  [[ -f "$file" ]] || return 0

  for string in "$@"; do
    if _string_in_file "$string" "$file"; then
      _sed_inplace "/^$(printf '%s' "$string" | sed 's/[^^]/[&]/g; s/\^/\\^/g')$/d" "$file"
    fi
  done
}

_string_in_file() {
  local string="$1" file="$2"
  grep -qxF "$string" "$file" 2>/dev/null
}

_sed_inplace() {
  if [[ "$(os)" == "mac" ]]; then
    sed -i '' "$@"
  else
    sed -i "$@"
  fi
}

# Creates symlinks in target_dir for each entry in the list
create_symlinks() {
  local target_dir="$1"
  shift
  local entries=("$@")

  for entry in "${entries[@]}"; do
    local name=$(basename "$entry")
    local link_path="$target_dir/$name"
    if [ ! -L "$link_path" ]; then
      ln -s "$entry" "$link_path"
    fi
  done
}


# Update the homebrew cache periodically
update_brew_if_needed() {
  local cache_duration="${HOMEBREW_UPDATE_CACHE_DURATION:-86400}" # default is 24 hours in seconds
  local cache_file="$PPM_CACHE_HOME/brew_last_update"

  if [[ ! -f "$cache_file" ]] || [[ $(($(date +%s) - $(cat "$cache_file"))) -gt $cache_duration ]]; then
    [[ ! -d $PPM_CACHE_HOME ]] && mkdir -p $PPM_CACHE_HOME
    brew update
    date +%s > "$cache_file"
  fi
}


# Install dependencies using the OS specific package manager (apt or homebrew)
install_dep() {
  if [[ "$(os)" == "linux" ]]; then
    sudo apt install "$@" -y
  elif [[ "$(os)" == "macos" ]]; then
    local cask_flag=""
    [[ "${1:-}" == "--cask" ]] && { cask_flag="--cask"; shift; }
    for dep in "$@"; do
      if ! brew list $cask_flag "$dep" &>/dev/null; then
        brew install $cask_flag "$dep"
      elif brew outdated $cask_flag --quiet | grep -q "^${dep}$"; then
        brew upgrade $cask_flag "$dep"
      fi
    done
  fi
}


# Manage sources in sources.list
src() {
  local subcommand="${1:-}"
  shift 2>/dev/null || true

  case "$subcommand" in
    add)
      local top=false
      [[ "${1:-}" == "--top" ]] && { top=true; shift; }

      if [[ $# -eq 0 ]]; then
        echo "Error: src add requires a git URL"
        echo "Usage: ppm src add [--top] <git-url>"
        exit 1
      fi

      local url="$1"

      # Create config directory if it doesn't exist
      mkdir -p "$PPM_CONFIG_HOME"

      # Create sources.list if it doesn't exist
      touch "$PPM_SOURCES_FILE"

      # Check if URL already exists in sources.list
      if grep -qxF "$url" "$PPM_SOURCES_FILE" 2>/dev/null; then
        echo "Source already exists: $url"
        return 0
      fi

      # Add URL to sources.list
      if $top; then
        local tmp=$(mktemp)
        echo "$url" > "$tmp"
        cat "$PPM_SOURCES_FILE" >> "$tmp"
        mv "$tmp" "$PPM_SOURCES_FILE"
      else
        echo "$url" >> "$PPM_SOURCES_FILE"
      fi
      echo "Added source: $url"
      ;;

    remove)
      if [[ $# -eq 0 ]]; then
        echo "Error: src remove requires a git URL"
        echo "Usage: ppm src remove <git-url>"
        exit 1
      fi

      local url="$1"

      if ! _string_in_file "$url" "$PPM_SOURCES_FILE"; then
        echo "Source not found: $url"
        return 1
      fi

      remove_from_file "$PPM_SOURCES_FILE" "$url"
      echo "Removed source: $url"
      ;;

    list)
      if [[ -f "$PPM_SOURCES_FILE" ]]; then
        cat "$PPM_SOURCES_FILE"
      else
        echo "No sources configured"
      fi
      ;;

    *)
      echo "Usage: ppm src <add|remove|list>"
      echo "  add [--top] <git-url>  Add a source repository"
      echo "  remove <git-url>       Remove a source repository"
      echo "  list                   List configured sources"
      [[ -z "$subcommand" ]] || exit 1
      ;;
  esac
}


collect_repos() {
  REPOS=()

  # Read file into array, skipping empty lines and comments
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    REPOS+=("$line")
  done < "$PPM_SOURCES_FILE"
}


collect_packages() {
  collect_repos
  PACKAGES=()

  for repo in "${REPOS[@]}"; do
    local repo_name="${repo##*/}"      # Remove everything before last /
    repo_name="${repo_name%.git}"      # Remove .git extension

    while IFS= read -r dir; do
      PACKAGES+=("$repo_name/$(basename "$dir")")
    done < <(ls -d $PPM_DATA_HOME/$repo_name/packages/*/)
  done
}


# Update ppm itself by downloading from the source URL
update_self() {
  echo "Updating ppm..."
  curl -fsSL -o "$PPM_BIN_FILE" "$PPM_BIN_URL"
  chmod +x "$PPM_BIN_FILE"
  echo "ppm updated successfully"
}

# Check if entry is a git URL (not a local path)
is_git_url() {
  [[ "$1" == git@* || "$1" == *://* ]]
}

# Iterate over repos listed in $PPM_SOURCES_FILE and clone them to $PPM_DATA_HOME
update() {
  # Handle self-update
  if [[ $# -gt 0 && "$1" == "ppm" ]]; then
    update_self
    return
  fi

  collect_repos

  # Iterate over repos and clone to $PPM_DATA_HOME
  for repo in "${REPOS[@]}"; do
    # Extract repo name (everything after last / and before .git)
    local repo_name="${repo##*/}"      # Remove everything before last /
    repo_name="${repo_name%.git}"      # Remove .git extension

    # Skip local paths that aren't git URLs
    if ! is_git_url "$repo"; then
      continue
    fi

    if [ ! -d $PPM_DATA_HOME/$repo_name ]; then
      echo "Cloning: $repo"
      git clone $repo $PPM_DATA_HOME/$repo_name
    else
      # Check for uncommitted changes or untracked files
      if ! git -C "$PPM_DATA_HOME/$repo_name" diff --quiet || \
         ! git -C "$PPM_DATA_HOME/$repo_name" diff --cached --quiet || \
         [[ -n $(git -C "$PPM_DATA_HOME/$repo_name" status --porcelain) ]]; then
        echo "Skipping $repo_name: has uncommitted changes. Please commit or stash them first."
        continue
      fi

      echo "Updating: $repo_name"
      git -C "$PPM_DATA_HOME/$repo_name" pull
    fi
  done
}


# List the packages found in the cached repositories
# Optionally filter by a substring pattern
list() {
  local filter="${1:-}"
  collect_packages
  for pkg in "${PACKAGES[@]}"; do
    if [[ -z "$filter" ]] || [[ "$pkg" == *"$filter"* ]]; then
      echo "$pkg"
    fi
  done
}


# Stow a package subdirectory and collect files for ignore_args
# Requires ignore_args array to be defined in caller's scope
stow_subdir() {
  local pkg_dir="$1" subdir="$2"
  local full_path="$pkg_dir/$subdir"

  [[ -d "$full_path" ]] || return 0

  # If force mode, remove conflicting files first
  $force && force_remove_conflicts "$full_path"

  stow --no-folding ${ignore_args[@]+"${ignore_args[@]}"} -d "$pkg_dir" -t "$HOME" "$subdir"

  while IFS= read -r file; do
    if [[ -n "$file" ]]; then
      local escaped="${file//./\\.}"
      ignore_args+=("--ignore=^${escaped}\$")
    fi
  done < <(package_links "$full_path")
}


package_links() {
  local path="$1"
  find "$path" -type f | while read -r file; do
    echo "${file#$path/}"
  done
}


# Remove files from $HOME that would conflict with stow
# Requires ignore_args array to be defined in caller's scope
force_remove_conflicts() {
  local full_path="$1"

  while IFS= read -r file; do
    [[ -z "$file" ]] && continue

    # Check if this file is in ignore_args (already stowed from previous subdir)
    local escaped="${file//./\\.}"
    local is_ignored=false
    if [[ ${#ignore_args[@]} -gt 0 ]]; then
      for arg in "${ignore_args[@]}"; do
        [[ "$arg" == "--ignore=^${escaped}\$" ]] && { is_ignored=true; break; }
      done
    fi

    # Remove the file from $HOME if it exists and isn't ignored
    if ! $is_ignored && [[ -e "$HOME/$file" || -L "$HOME/$file" ]]; then
      rm -f "$HOME/$file"
    fi
  done < <(package_links "$full_path")
}


# Install one or more packages as requested by the user
install() {
  [[ "$(os)" == "macos" ]] && update_brew_if_needed
  if $reinstall; then
    remove "$@"
  fi
  installer "$@"
}

installer() {
  collect_repos
  requested_packages=("$@")

  for pkg in "${requested_packages[@]}"; do
    local package_repo=$(dirname "$pkg") package_name=$(basename "$pkg") ignore_args=()
    # Is the package requested from a specific repo (ppm install repo/pkg)
    [[ "$pkg" == */* ]] && single_repo="true" || single_repo="false"

    for repo in "${REPOS[@]}"; do
      # Extract repo name (everything after last / and before .git)
      local repo_name=$(basename "$repo" .git)

      # Skip unmatched repos if package is requested from a specific repo
      [[ "$single_repo" == "true" && "$repo_name" != "$package_repo" ]] && continue

      # If the package is not found in this repo then skip to the next repo
      package_dir=$PPM_DATA_HOME/$repo_name/packages/$package_name
      [[ ! -d $package_dir ]] && continue
      echo "Install $repo_name/$package_name"

      # No installer - just stow and continue
      if [[ ! -f "$package_dir/install.sh" ]]; then
        stow_subdir "$package_dir" "home"
        [[ -n "${PPM_GROUP_ID:-}" ]] && stow_subdir "$package_dir" "$PPM_GROUP_ID"
        continue
      fi

      # Has installer - handle dependencies and pre_install
      (
        source "$package_dir/install.sh"
        if type dependencies &>/dev/null; then
          deps=$(dependencies)
          for dep in $deps; do
            "$0" "installer" ${config_flag:+"$config_flag"} ${force_flag:+"$force_flag"} "$dep"
          done
        fi
        if type pre_install &>/dev/null && [[ -z "$config_flag" ]]; then
          pre_install
        fi
      )

      # Stow files (must be in main shell to persist ignore_args across repos)
      stow_subdir "$package_dir" "home"
      [[ -n "${PPM_GROUP_ID:-}" ]] && stow_subdir "$package_dir" "$PPM_GROUP_ID"

      # Post-install, OS-specific install, and space setup
      (
        source "$package_dir/install.sh"

        func_name="install_$(os)"
        if type $func_name &>/dev/null && [[ -z "$config_flag" ]]; then
          $func_name
        fi

        if type post_install &>/dev/null && [[ -z "$config_flag" ]]; then
          post_install
        fi

        if type "space_path" &>/dev/null; then
          if ! command -v hub >/dev/null 2>&1; then
            echo "WARN: Cannot install $repo_name/$package_name space. Run 'ppm install chorus'"
            continue
          fi
          mkdir -p $(space_path)
          if [[ -d $package_dir/space ]]; then
            stow -d $package_dir -t $(space_path) space
          fi
          if type "space_install" &>/dev/null; then
            pushd $(space_path) > /dev/null
            space_install
            popd > /dev/null
          fi
        fi
      )
    done
  done
}


# Remove one or more packages as requested by the user
remove() {
  collect_repos

  requested_packages=("$@")
  for pkg in "${requested_packages[@]}"; do

    for repo in "${REPOS[@]}"; do
      # Extract repo name (everything after last / and before .git)
      local repo_name="${repo##*/}"      # Remove everything before last /
      repo_name="${repo_name%.git}"      # Remove .git extension

      pkg_dir=$PPM_DATA_HOME/$repo_name/packages/$pkg

      # If the package name is not found then skip to the next
      if [[ ! -d $pkg_dir ]]; then
        continue
      else
        echo "Remove $repo_name/$pkg"
        [[ -f "$pkg_dir/install.sh" ]] && has_installer=true || has_installer=false
      fi

      if $has_installer; then
        (
          source "$pkg_dir/install.sh"
          if type pre_remove &>/dev/null; then
            pre_remove
          fi
        )
      fi

      # Use stow to remove softlinks from the user's home directory
      [[ -d $pkg_dir/home ]] && stow -D -d $pkg_dir -t $HOME home

      if $has_installer; then
        (
          source "$pkg_dir/install.sh"
          # if type paths &>/dev/null; then
          #   pkg_dirs=$(paths)
          #   for dir in $pkg_dirs; do
          #     rm -rf $dir
          #   done
          # fi
          func_name="remove_$(os)" # remove_linux or remove_macos
          if type $func_name &>/dev/null; then
            $func_name
          fi
          if type post_remove &>/dev/null; then
            post_remove
          fi
        )
      fi
    done
  done
}


# Output shell completions for zsh or bash
completions() {
  local shell="${1:-zsh}"

  case "$shell" in
    zsh)
      cat <<'EOF'
#compdef ppm

_ppm() {
    local -a subcommands
    local state

    subcommands=(
        'src:Manage source repositories (add, remove, list)'
        'update:Update repositories (or "ppm update ppm" to update ppm itself)'
        'list:List available packages'
        'install:Install one or more packages'
        'remove:Remove one or more packages'
        'show:Show package information'
        'completions:Output shell completions'
    )

    _arguments -C \
        '1: :->command' \
        '*: :->args'

    case $state in
        command)
            _describe 'command' subcommands
            ;;
        args)
            case ${words[2]} in
                src)
                    if [[ ${#words[@]} -eq 3 ]]; then
                        local -a src_cmds
                        src_cmds=('add:Add a source repository' 'remove:Remove a source repository' 'list:List configured sources')
                        _describe 'subcommand' src_cmds
                    fi
                    ;;
                install|remove|show)
                    _ppm_packages_available
                    ;;
                update)
                    local -a update_opts
                    update_opts=('ppm:Update ppm itself')
                    _describe 'target' update_opts
                    ;;
                completions)
                    local -a shells
                    shells=('zsh' 'bash')
                    _describe 'shell' shells
                    ;;
            esac
            ;;
    esac
}

_ppm_packages_available() {
    local -a packages
    local ppm_data_home="${XDG_DATA_HOME:-$HOME/.local/share}/ppm"

    if [[ -d "$ppm_data_home" ]]; then
        for repo_dir in "$ppm_data_home"/*/packages; do
            [[ -d "$repo_dir" ]] || continue
            local repo_name="${repo_dir%/packages}"
            repo_name="${repo_name##*/}"
            for pkg_dir in "$repo_dir"/*/; do
                [[ -d "$pkg_dir" ]] || continue
                local pkg_name="${pkg_dir%/}"
                pkg_name="${pkg_name##*/}"
                packages+=("${repo_name}/${pkg_name}")
            done
        done
    fi

    _describe 'package' packages
}

compdef _ppm ppm
EOF
      ;;
    bash)
      echo "# Bash completions not yet implemented"
      ;;
    *)
      echo "Error: Unknown shell '$shell'. Supported: zsh, bash" >&2
      return 1
      ;;
  esac
}


# Show package information: dependencies and directory trees
show() {
  if [[ $# -eq 0 ]]; then
    echo "Error: show requires a package name"
    echo "Usage: ppm show [repo/]package"
    exit 1
  fi

  collect_repos

  local pkg="$1"
  local package_repo=$(dirname "$pkg") package_name=$(basename "$pkg")
  [[ "$pkg" == */* ]] && single_repo="true" || single_repo="false"

  local found=false

  for repo in "${REPOS[@]}"; do
    local repo_name=$(basename "$repo" .git)

    # Skip unmatched repos if package is requested from a specific repo
    [[ "$single_repo" == "true" && "$repo_name" != "$package_repo" ]] && continue

    local package_dir=$PPM_DATA_HOME/$repo_name/packages/$package_name
    [[ ! -d $package_dir ]] && continue

    found=true
    echo "Package: $repo_name/$package_name"
    echo ""

    # Show dependencies if install.sh exists
    if [[ -f "$package_dir/install.sh" ]]; then
      (
        source "$package_dir/install.sh"
        if type dependencies &>/dev/null; then
          echo "Dependencies:"
          deps=$(dependencies)
          for dep in $deps; do
            echo "  - $dep"
          done
          echo ""
        fi
      )
    fi

    # Show home tree if it exists
    if [[ -d "$package_dir/home" ]]; then
      echo "home/"
      if command -v tree &>/dev/null; then
        tree -a --noreport "$package_dir/home" | tail -n +2
      else
        find "$package_dir/home" -type f | sed "s|$package_dir/home/|  |"
      fi
      echo ""
    fi

    # Show space tree if it exists
    if [[ -d "$package_dir/space" ]]; then
      echo "space/"
      if command -v tree &>/dev/null; then
        tree -a --noreport "$package_dir/space" | tail -n +2
      else
        find "$package_dir/space" -type f | sed "s|$package_dir/space/|  |"
      fi
      echo ""
    fi
  done

  if ! $found; then
    echo "Error: Package '$pkg' not found"
    exit 1
  fi
}


# Entrypoint
main() {
  if [[ ! -f $PPM_SOURCES_FILE ]]; then
    echo "ERROR: Missing $PPM_SOURCES_FILE"
    exit 1
  fi
  # Source all *.conf files from PPM_CONFIG_HOME
  set -a
  for conf_file in "$PPM_CONFIG_HOME"/*.conf; do
    [[ -f "$conf_file" ]] && source "$conf_file"
  done
  set +a

  local command="$1" config=false config_flag="" force=false force_flag="" reinstall=false reinstall_flag=""
  shift

  while [[ "$#" -gt 0 && "$1" == -* ]]; do
    case "$1" in
      -c) config=true; config_flag="-c" ;;
      -f) force=true; force_flag="-f" ;;
      -r) reinstall=true; reinstall_flag="-r" ;;
      *) echo "Unknown flag: $1"; exit 1 ;;
    esac
    shift
  done

  if declare -f "$command" > /dev/null; then
    "$command" "$@"
  else
    echo "Error: Unknown command '$command'"
    list_commands
    exit 1
  fi
}

# Skip main() setup for commands that don't need it
case "${1:-}" in
  completions) completions "${@:2}" ;;
  src) src "${@:2}" ;;
  *) main "$@" ;;
esac
